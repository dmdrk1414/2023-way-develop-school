![image-20221107005314995](C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221107005314995.png)

# 깃 허브 내용정리

### 1. 커밋 메시지

- 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

- gitaddcommit   : git add . && git commit 
- gitaddcommitmemo : git add . && git commit -m ":memo:[Comment] 구현 기능 목록 수정"
- git add . && git commit -m ":memo:[Comment] 구현 기능 목록 수정"



- [Style(baseball)] 주석 추가
- [Refactor(baseball)] 매직 넘버 수정

| 아이콘                                                       | 코드                                                  |
| :----------------------------------------------------------- | ----------------------------------------------------- |
| :sparkles:[Feat]                                             | 새 기능 추가                                          |
| :white_check_mark:[Test]                                     | 테스트 추가/수정                                      |
| :recycle:[Refactor]                                          | 코드 리팩토링                                         |
| :ambulance: [Fix]                                            | 버그 수정                                             |
| :fire:[Remove]                                               | 코드/파일 삭제                                        |
| :tada:[Add]                                                  | 클래스생성                                            |
| :lipstick:[Style]                                            | 코드 포맷 변경, 세미 콜론 누락, 코드 수정이 없는 경우 |
| git add . && git commit -m ":memo:[Comment] 구현 기능 목록 수정" | 문서 추가/수정                                        |
| git add . && git commit -m ":truck:[Rename \|\|Move] "       | 리소스 이동, 이름 변경                                |
| git add . && git commit -m ":bulb:[Style] 필요없는 주석 삭제 및 수정" | 주석 추가/수정                                        |
| :poop:                                                       | 똥싼 코드                                             |
| [Feat(christmas)] 기능 추가                                  |                                                       |
| [Style(christmas)] 주석 수정                                 |                                                       |
| [Style(christmas)] 주석 삭제                                 |                                                       |
| [Style(christmas)] 주석 추가                                 |                                                       |
| [Style(christmas)] 공백 삭제                                 |                                                       |
| [Style(christmas)] 공백 추가                                 |                                                       |
| [Docs(christmas)] 기능 목록표 수정                           |                                                       |
| [Refactor(christmas)] Test 수정                              |                                                       |
| [Refactor(christmas)] 메서드의 분리                          |                                                       |
| [Refactor(christmas)] 메서드 이름 변경                       |                                                       |
| [Refactor(christmas)] 변수 이름 변경                         |                                                       |
| [Refactor(christmas)] 상수 추가                              |                                                       |
| [Remove(christmas)] 안쓰는 코드 삭제                         |                                                       |
| [Refactor(christmas)] 필드에 final 추가                      |                                                       |

```
            "티본스테이크-1바비큐립-1초코케이크-2제로콜라-1, 142000",
            "타파스-1제로콜라-1, 8500",
            "양송이수프-1타파스-2티본스테이크-1아이스크림-3제로콜라-2, 93000",
            "양송이수프-1타파스-1아이스크림-4제로콜라-2, 37500",
            "시저샐러드-2바비큐립-1초코케이크-1레드와인-1, 145000",
```



### 2. 바로 직전 커밋 메세지 수정하고 싶을 때

```
git commit --amend
```

### 3. git rebase -i로 커밋 수정 작업 실시

특정 커밋 수정.

```
git rebase -i [Commit ID]
```

### 4. 바로 직전 커밋에 새로 작성한 코드 추가하기

```
git add .
git commit --amend
```

### 5. Head부터 3번째 까지 커밋 수정

```
git rebase -i Head~3
```

### 6. 직전 커밋 삭제

```
git reset HEAD^
```

# ========== 테스트 시작 ========== 





# Assertions 기본문법

## 반복 가능/배열 내용 확인

주장 에는 다양한 종류가 있습니다 `contains`. 가장 관련성이 높은 것을 선택하는 데 도움이 되는 표는 다음과 같습니다.

| 역설                                                         | 설명                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `contains`                                                   | 실제 반복 가능/배열에 주어진 값이 어떤 순서로든 포함되어 있는지 확인합니다. |
| `containsOnly`                                               | 실제 그룹에 지정된 값만 포함되어 있고 순서에 관계없이 다른 항목이 포함되지 않았는지 확인하고 중복 항목을 무시합니다(즉, 값이 발견되면 해당 중복 항목도 발견된 것으로 간주됩니다). |
| `containsExactly`                                            | 실제 반복 가능/배열에 주어진 값이 정확히 포함되어 있고 **순서대로 다른 항목은 포함되어 있지 않은지 확인합니다.** |
| `containsExactlyInAnyOrder`                                  | 실제 반복 가능/배열에 지정된 값이 정확히 포함되어 있고 **순서에 관계 없이 다른 항목이 포함되어 있지 않은지 확인합니다.** |
| `containsSequence`                                           | 실제 그룹에 지정된 시퀀스가 올바른 순서로 포함되어 있고 **시퀀스 값 사이에 추가 값이 없는지 확인합니다.** |
| `containsSubsequence`                                        | 실제 그룹에 주어진 하위 시퀀스가 올바른 순서로 포함되어 **있고 그 사이에 다른 값이 있는지 확인합니다.** |
| `containsOnlyOnce`                                           | 실제 반복 가능/배열에 주어진 값이 한 번만 포함되어 있는지 확인합니다. |
| `containsAnyOf`                                              | 실제 반복 가능/배열에 주어진 값 중 적어도 하나가 포함되어 있는지 확인합니다( `or`주어진 값에 대한 연산자와 유사). |
| `extracting`                                                 | 각 요소에서 추출(또는 전달)할 필드/속성을 지정 `Function`하고 추출된 값에 대해 어설션을 수행합니다. |
| `extracting().contains(tuple)`                               | 여러 값 추출, 테스트 중인 요소에서 여러 값을 추출하고 투플을 사용하여 확인가능하다. |
| `flatExtracting("리스트이름")                             .contains();` | 리스트의 원소값인 클래스안의 리스트의 값을 추출한다.         |







# 테스트

# ---- Parameter 매개변수 테스트

### 0. CsvSource을 이용한 각각의 매개면수에 원하는 값 넣기

```java
    @DisplayName("유저의 입력한 숫자중 특정한 index의 값의 숫자와 컴퓨터의 저장된 3개의 숫자중 특정 index에 숫자가 같은지 확인한다.")
    @ParameterizedTest
    @CsvSource({"0,1,true", "1,2,true", "2,3,true", "0,4,false", "1,4,false", "2,4,false"})
    public void isSamePlaceNumUserAndComputerTest(String placeIndexOfUser, int numIndexPlaceOfUser, boolean expectResult) throws Exception {

    }
}
```

### 1. String 변수 받는법

```java
@ParameterizedTest(name = "매개변수") // 무조건 name으로
@ValueSource(strings = {"q", "qwerasdfzxcv", "qq23"})
@DisplayName("String 변수 받는법")
void 매개변수를_테스트하는법(String name){
  assertThat(name).contains("1");
}
```

# 2. null 변수에 넣는법

### 3. empty 빈것을 변수 넣는법

```java
@ParameterizedTest
@NullSource
@EmptySource
void nullEmptyStrings(String text) {
    assertTrue(text == null || text.trim().isEmpty());
}
```

### 4. null 과 empty 를 넣는다.

```java
@ParameterizedTest
@NullAndEmptySource
@ValueSource(strings = { " ", "   ", "\t", "\n" })
void nullEmptyAndBlankStrings(String text) {
    assertTrue(text == null || text.trim().isEmpty());
}
```

### 5. null, empty, 매개변수 

```java
@ParameterizedTest
@NullSource
@EmptySource
@ValueSource(strings = {"1", "13"})
void nullEmptyStrings(String text) {
    assertTrue(text == null || text.trim().isEmpty() 
               || Integer.parseInt(text) > 0 && Integer.parseInt(text) < 4);
}
```



# ---- Exception_예외 테스트

### 1. assertThrows 

```java
import static org.junit.jupiter.api.Assertions.assertThrows;

@Test
void 예외를_던지는_테스트() {
	// given
	String input = "pobi,crong,honuxxx";
	// when then
	assertThrows(IllegalArgumentException.class, (원소의값) -> 메소드콜());
}
```

```java
 assertThrows(IllegalArgumentException.class, user::getInputAllRightNumOfUser);
 assertThrows(IllegalArgumentException.class, Class::메서드명);
```

### 2. assertThatThrownBy

```java
@Test
void charAt_메서드_사용시_문자열의_길이보다_큰_숫자_위치의_문자를_찾을_때_예외_발생() {
  String input = "abc";

   assertThatThrownBy(() -> input.charAt(5))
      .isInstanceOf(StringIndexOutOfBoundsException.class)
      .hasMessageContaining("String index out of range: 5");
}

@Test
public void exception_assertion_example() {
    assertThatThrownBy(() -> { throw new Exception("boom!");        }).isInstanceOf(Exception.class)
       .hasMessageContaining("boom");
};

// #2
        Assertions.assertThatThrownBy(
                        () -> ValidException.isValidFIveLessString(input))
                .isInstanceOf(IllegalArgumentException.class);
```

### 3. assertThatExceptionOfType 

**예외가 발생하는지 확인**

```java
    @Test
    public void testException() {
        assertThatExceptionOfType(IOException.class).isThrownBy(() -> { throw new IOException("boom!"); })
                .withMessage("%s!", "boom")
                .withMessageContaining("boom")
                .withNoCause();
    }
```



# ---- 입력(in), 출력(out) 테스트

### 1. 입력(in)과 출력(out)을 확인하는 테스트

```java
출력(out)  
	private ByteArrayOutputStream outContent;

    @BeforeEach
    void setUp() {
        outContent = new ByteArrayOutputStream();
        System.setOut(new PrintStream(outContent));
    }

    @DisplayName("print new Line 테스트")
    @Test
    void printNewLine() {
        // when
        Utill.printNewLine();

        // than
        assertThat(outContent.toString()).isEqualTo("\n");
    }
```



```java
public class CalculatorTest {	
    // 필수
    private static Calculator calculator; 
    private static final String errMsg = "계산식을 입력해주세요.\n올바른 계산식을 입력해주세요.\n";
    @BeforeAll // (테스트 콜한때 한번 출력)
    static void initAll() {
        calculator = new Calculator();
    }
@Test
    void 입력_출력값을_테스트() {
       // given
       // 출력을 담는다.
       OutputStream out = new ByteArrayOutputStream();
       System.setOut(new PrintStream(out));
        
       // 입력을 담는다.
       String input = "입력하고싶은_문자열";
       InputStream in = new ByteArrayInputStream(input.getBytes());
       System.setIn(in);
       // when 
       calculator.start();
       // then
       Assertions.assertThat(errMsg).isEqualTo(out.toString());
    }
}
```

```java
public class UserTest {
    private static User user;
    @BeforeAll
    static void initAll() {
        user = new User();
    }
    @Test
    void 문자_입력_테스트() throws Exception {
        //given
        User user = new User();
        String input = "123";

        // 입력을 담는다.
        InputStream in = new ByteArrayInputStream(input.getBytes());
        System.setIn(in);
        // when
        int result = user.getInputAllRightNumOfUser();
         // then
        assertThat( (int)result).isEqualTo(123);
    }
```



# ---- int 테스트

### 1. 숫자가 같은지 확인하는 테스트

```
// then
assertThat( (int)result).isEqualTo(123);
```



# ---- List 테스트

### 1. List의 모든 원소에 대한 확인 하는 테스트

```
assertThat(resultList).allMatch((value) -> {
    return value.equals(true);
});
```

### 2. 두개의 List가 같은지(Equals) 확인하는 테스트

```java
   @Test
    void 컴퓨터_랜덤숫자_리스트_초기화() throws Exception {
        //given
        Computer computer = new Computer();
        // when
        computer.initComputer();
        List<Integer> resultList_1 = computer.getNumThreeRanOfComputerList();
        computer.initComputer();
        List<Integer> resultList_2 = computer.getNumThreeRanOfComputerList();
        // then
        // 방법 1 assertNotEquals
        assertNotEquals(resultList_1, resultList_2);
        // 방법 2 assertThat().isFalse
        assertThat( resultList_1.equals(resultList_2) ).isFalse();
    }
```

```java
 assertThat(ResultList).containsAll(trueList);
```

### 3. 두개의 List가 다른지(NotEquals) 확인하는 테스트

```java
assertNotEquals(resultList_1, resultList_2);
```



# ---- String 테스트

### 1. 문자열을 비교하는 테스트

```java
assertThat( (String)result).contains("1");
```

### 2. charAt 메서드로 특정 위치의 문자 찾기

```java
    @Test
    void charAt_메서드로_특정_위치의_문자_찾기() {
        String input = "abc";
        char charAtElement = input.charAt(0);
        assertThat(charAtElement).isEqualTo('a');
    }
```

### 3. substring 메서드를 이용한 특정 구간 값을 반환

```java
   @Test
    void substring_메서드로_특정_구간_값을_반환() {
        String input = "(1,2)";
        String result = input.substring(1, 4);

        assertThat(result).isEqualTo("1,2");
    }
```

### 4. 문자열에 대한 검증

```java
@Test
void 문자열_검증() {
 String expression = "This is a string";
 assertThat(expression).startsWith("This").endsWith("string").contains("a");
}
```



# ---- Boolean 테스트

### 1. boolean을 확인하는 테스트

```java
 // true
 assertThat( resultList_1.equals(resultList_2) ).isTrue();

 assertTrue( (boolean)isTrue );

 // false
 assertThat( resultList_1.equals(resultList_2) ).isFalse();


```



# ---- Enum 테스트

```java
@ParameterizedTest
//          value = 이넘의 이금 정의  names =  이넘의 값을 정의
@EnumSource(value = TimeUnit.class, names = {"DAYS", "HOURS"})
void testWithEnumSourceInclude(TimeUnit timeUnit) {
   assertTrue(EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(timeUnit));
}
```



# ---- 테스트 할시 main 함수 담는법

```java
   @Override
    public void runMain() {
        Application.main(new String[]{});
    }
```



# ---- contains  

### 1. contains

**하나라도 포함이 되어있으면 테스크 통과**

```java
// **하나라도 포함이 되어있으면 테스크 통과**
String input = "1,,23";
        String[] result = input.split(",");

        assertThat(result).contains("1");
```

### 2. containsAnyOf

**이중 하나가 포함되어있다.**

```java
    @Test
    void a_few_simple_assertions() {
        assertThat("The Lord of the Rings")
            // 널이 아니고
            .isNotNull()
            // The로 시작하고
            .startsWith("The")
            // Lord가 포함하고
            .contains("Lord")
            .contains("of")
            // 이중에 하나가 포함되었다.
            .containsAnyOf("the", "rings")
            // 끝이 Rings이다.
            .endsWith("Rings");
    }
```

```java
    @Test
    void a_few_simple_assertions_2() {
        assertThat("123")
            // 널이 아니고
            .isNotNull()
            // The로 시작하고
            .startsWith("1")
            // Lord가 포함하고
            .contains("3")
            .contains("2")
            // 이중에 하나가 포함되었다.
            .containsAnyOf("1", "aslkdjasd", "아무단어")
            // 끝이 Rings이다.
            .endsWith("3");
    }
```

### 3. containsExactly  

**순서와 정확하게 포함이 되었는가 확인** / 순서 갯수 정확

```java
@Test
    // 정확하게 포함이 되었는가 확인
void split_메서드로_주어진_값을_구분_2() {
    String input = "1,,23";
    String[] result = input.split(",");

    assertThat(result).contains("1");

    // 정확하게 들어있는가
    assertThat(result).containsExactly("1", "", "3");
}
```

### 4. containsOnly - 여기

**순서, 중복을 무시하는 대신 원소값과 갯수가 정확히 일치** / 갯수

```java
     //  이름을 가져와서 a 가 포함되어 있는 객체들만 필터링을 하고 그 객체를 검증한다.
        assertThat(list).filteredOn(human -> human.getName().contains("a"))
            .containsOnly(park, jack);
```



# ---- filterOn메서드를 이용한 객체 테스트

### 1. 필터링하고 객체 검증 

```java
   //  이름을 가져와서 a 가 포함되어 있는 객체들만 필터링을 하고 그 객체를 검증한다.
assertThat(list).filteredOn(human ->  human.getName().contains("a"))
            .containsOnly(jack, anyName, park);
```

### 2. 객체의 멤버변수의 값 검증

```java
Human park = new Human("Park", 25);
Human lee = new Human("Lee", 25);
Human amy = new Human("Amy", 22);

List<Human> list = new ArrayList<>();

assertThat(list).filteredOn("age", 25).containsOnly(park, lee);
```



# ---- extracting 객체의 프로퍼티 추출하기(멤버변수) 

### 1. extracting을 이용한 객체 프로퍼트 추출 멤버변수 추출

```java
List<Human> list = new ArrayList<>();
Human kim = new Human("Kim", 22);
Human park = new Human("Park", 25);
Human lee = new Human("Lee", 25);

list.add(kim);
list.add(park);
list.add(lee);

assertThat(list).extracting("name").contains("Kim", "Park", "Lee");
assertThat(list).extracting("age").contains(22, 25, 25);

// 검증의 타입을 강하게 설정할때 유용하다.
assertThat(list).extracting("name", String.class).contains("Kim", "Park", "Lee", "Amy", "Jack");

// tuple을 이용한 강한 검증방법
assertThat(list).extracting("name", "age")
     .contains(
        tuple("Kim", 22),
        tuple("Park", 25),
        tuple("Lee", 25)
            );
```





# ========== 예외 처리 시작 ========== 

## ---- List 예외처리



# - 예외 코드 정리.

## ---- String 예외처리

### 1. String 길이 관련 예외처리

```java
// 길이 관련 예외처리
if (String.length() >= 1 && String.length() <= 30)
			throw new IllegalStateException("String의 길이가 올바르지 않습니다.");
```

### 2. String에 각자리에 대문자가 있는가? 예외처리

```java
// 유저 아이디에 대문자
if (String.chars().anyMatch(Character::isUpperCase)))
			throw new IllegalStateException("String의 각자리의 CHar중 대문자가 있습니다.");
```

### 3. String에 각자리에 소문자가 있는가? 예외처리

```java
if (cryptogram.chars().allMatch(Character::isUpperCase))
			throw new IllegalStateException("문자열이 소문자로 이루어져있지 않습니다.");
```

## 

### 1. List 원소의 모든 원소중 크기 예외 처리.

```java
if (List.stream().anyMatch(list -> list.size() != 2))
            throw new IllegalStateException("List의 원소중 갯수가 올바르지 않습니다.");
```

### 2. List의 사이즈 크기에 관한 예외처리

```java
if (List.size() < 1 || List.size() > 10000)
            throw new IllegalStateException("List의 길이가 올바르지 않습니다");
```

### 3. List의 모든 원소중 모두 길이가 맞지 않는가 예외처리

```java
if (!List.stream().allMatch(onboarding.Main::isValidIdLength))
    throw new IllegalStateException("List의 원소중 길이가 맞지않는 아이디가 있습니다.");
 
public boolean isValidIdLength(String str) {
        if (str.length() >= 1 && str.length() <= 30)
            return true;
        return false;
    }
```

### 4. List의 모든 원소중 대문자가 있는 String이있는가 예외처리

```java
if (List.stream().anyMatch(onboarding.Main::isContainUpperClass)) {
         throw new IllegalStateException("List의 원소중 대문자가 있는 아이디가 있습니다.");
    
public boolean isContainUpperClass(String str) {
        if (str.chars().anyMatch(Character::isUpperCase))
            return true;
        return false;
    }
```



## ---- List\<List> 예외처리

### 5. LIst\<List>의 모든 원소중(List) 모든 원소 길이 예외 처리.

```java
if (!List<List>.stream().allMatch(List ->                                                  List.stream().allMatch(onboarding.Main::isValidIdLength)))
 throw new IllegalStateException("List의 원소중(List) 길이가 올바르지 않은 아이디가 있습니다.");

public boolean isValidIdLength(String str) {
        if (str.length() >= 1 && str.length() <= 30)
            return true;
        return false;
    }
```

### 6. List\<List>의 모든 원소중(List) 특정 원소 길이예외처리

```java
                                                               form.get(0)
if (!List<List>.stream().allMatch(List -> isValidEmailLength( 특정원소의 값 )))
 throw new IllegalStateException("List<List> List의 원소중 이메일의 길이가 올바르지 않습니다");

 public boolean isValidEmailLength(String email) {
        if (email.length() >= 11 && email.length() <= 19)
            return true;
        return false;
    }
```

### 7. List\<List>의 모든 원소중(List) 원소가 하나라도 대문자가 있는 경우

```java
if (List<List>.stream().anyMatch(List -> List.stream().anyMatch(onboarding.Main::isContainUpperClass)))
       throw new IllegalStateException("List의 원소중(List) 대문자가 있는 아이디가 있습니다.");

public boolean isContainUpperClass(String str) {
        if (str.chars().anyMatch(Character::isUpperCase))
            return true;
        return false;
    }
```

### 8. List<List>의 allMatch을 이용하여 모든 리스트 확인하기

```java
                                                               form.get(0)
if (!List<List>.stream().allMatch(List -> isValidEmailDomain( 특정원소의 값 )))
 throw new IllegalStateException("List<List> List의 원소중 <정규표현식>에 올바르지 않습니다.");

private final String DOMAIN_REGEX = ".*@email.com$";
public boolean isValidEmailDomain(String email) {
        if (email.matches(DOMAIN_REGEX))
            return true;
        return false;
    }
```

### 9. List 의 anyMatch을 이용하여 하나라도 포함되면.

```java
                                                                   form.get(0)
if (List<List>.stream().anyMatch(List -> isNicknameContainsEnglish( 특정원소의 값 )))
 throw new IllegalStateException("List<List> List의 원소중 <어디에> 영어가 포함되어있습니다.");

public boolean isNicknameContainsEnglish(String nickname) {
     if (nickname.chars().anyMatch(c -> (c >= 65 && c <= 90) || (c >= 97 && c <= 122)))
            return true;
        return false;
    }
```













# 2주차 소감문

```
	이번 2주 차 과제인 자동차 경주 코드를 작성하면서 1주 차 공통 피드백을 참고했습니다. 피드백에는 이름을 통해 의도를 드러내고, 배열 대신 Java Collection을 사용하며, Java에서 제공하는 API를 적극 활용하라는 내용이 있었습니다. 또한 의미 없는 주석을 달지 않고 공백 라인을 적절히 사용하는 것도 중요하다는 조언이었습니다. 이러한 내용에 대해 정말 감사했고, 모든 코딩에는 정답이 없지만 좋은 규격이 있다고 생각하고 있어서 고민하고 토론하는 과정에서 막연함을 느끼고 있었습니다. 그러나 선생님들의 피드백을 통해 막연한 코딩 습관을 고칠 수 있고 개선해 나갈 수 있어서 정말 좋았습니다. 감사합니다.

	함수 분리에 관한 공부 방법으로는 인터넷 검색과 책 "클린 코드"을 참고했습니다. 유튜브 우아한 테크 세미나에서 함수 분리에 관한 내용을 보고 다양한 개발자들의 생각을 알아보고, 집에 있는 Clean Code의 3장 함수 부분을 읽으며 생각을 정리하는 시간을 가졌습니다. 선생님들의 의견을 종합하여 제 나름의 규칙을 정했습니다. "작은 기능부터 분리하자"라는 규칙을 따라 메서드를 분리하는 작업을 시작했습니다. 요구 사항 분석을 통해 기능 구현을 완료한 후에는 제 코드를 관찰하며 작은 기능을 메서드로 만들었습니다. 메서드를 만들 때는 해당 메서드가 공통으로 사용되는지, 아니면 해당 클래스에서만 사용되는지를 고려했습니다. 필요한 경우에는 Util 클래스에 메서드를 만들고 메서드를 이동시켰습니다. 메서드를 분리하는 것은 정말 어려운 작업이었지만, 메서드의 이름과 매개 변수를 최대한 줄이고 공통으로 사용하는지 클래스에서만 사용하는지를 고민하는 시간이었습니다. 이런 고민이 성장의 과정이라는 것을 알기에 최대한 즐기며 작업했습니다.

	메서드의 분리를 진행하면서 클래스와 방법의 이름 계층 구조에 대해 깨달았습니다. 1주 차 피드백에서 클래스의 이름이 이미 명시되어 있기 때문에 메서드의 이름을 또 언급할 필요가 없다는 내용이 있었습니다. 처음에는 이해하기 어려웠지만, 메서드 분리 작업을 완료한 후에는 클래스의 이름과 메서드의 이름이 비슷하다는 것을 알았습니다. 예를 들어 RaceCar.moveControlOfRaceCar라는 메서드를 RaceCar.moveControl로 변경하는 시점에서 객체 지향적인 사고가 확장되었고, 클래스와 메서드 간의 계층 구조를 파악하는 시간이었습니다. 박승찬이라는 클래스가 있고 해당 클래스의 속성과 행동을 정의하는 과정과 RaceCar 클래스에 속성과 행동을 정의하는 과정이 동일하다는 것을 알아서 다음 과제에 적용할 수 있도록 숙달하겠다는 결심을 했습니다.

	테스트 코드 작성을 완료하고 제출서를 작성하는 시점에서 아쉬움이 크게 드는 것 같습니다. 기능 구현 유형별로 테스트 코드를 작성하는 과정에서 블로그와 유튜브를 참고했습니다. 그러나 기능 구현을 완료한 후에 Assertions 공식 문서를 확인하며 각각의 메서드를 검토했습니다. 공식 문서를 공부하면서 여러 Assertions 문법을 활용하지 않았다는 것을 깨달았고, 테스트 코드를 추가하고 있습니다.

	테스트 코드 작성 과정에서 다양한 예외에 대한 단위 테스트를 진행했습니다. given, when, then의 방식을 따라가며 테스트 코드를 작성하고, 요구사항이 제대로 이행되었는지 확인하며 좋은 테스트 코드가 무엇인지 고민했습니다. 이 과정에서 "테스트 코드는 현재 코드의 온점과 같다"는 생각했습니다. 현재 작성한 코드가 제대로 실행되는지 확인하는 것이 애매모호하다고 느껴졌지만, 테스트 코드를 작성하고 메서드의 테스트가 통과되는 것을 보고, 제 코드가 확실하게 동작한다는 것을 확인하고 다음 작업을 진행할 수 있었습니다. 그래서 테스트 코드는 "작업에 대한 확신"이라고 할 수 있지만, 테스트 코드를 신뢰하여 작업을 진행하는 것의 위험성도 인식하며 테스트 코드를 숙달하겠습니다.

```



# 3주차 소감문

- [x] 객체 생성 Config 클래스 생성
- [x] enum의 적용 - Statistic클래스 적용
- [x] 검증 클래스의 분리하여 관리
- [x] 예외처리 NumberFormatException의 적용이 맞는지
- [x] 메서드의 이름
- [x] 일급 콜렉션 생성
- [x] 클래스의 분리 
- [x] 실수 - 이번 과제의 문제 작은 단위의 클래스 부터 구현을 하였더니 너무 힘들었다.
- [x] 상수의 관리 - 이번에는 해당 클래스에 관련 상수를 넣었다.
- [x] 메서드의 이름 사람은 알려준다. (의인화), 협력 클래스들(사물과 같은) 얻는다, 준다. 받는다

```
  다양한 코드들을 검토하며 2주차 코드 리뷰를 진행하였습니다. 원활한 코드 리뷰를 통해 효율적인 방법을 채택하였고, 별도의 학습을 통해 코드의 유지보수성과 확장성을 강화하는 방향으로 노력하였습니다.

"외부 객체 생성"
  Config 클래스를 생성하여 객체를 초기화하였습니다. 클래스의 분리에 대한 학습 과정에서 '관심사의 분리를 위해 제3의 클래스를 생성'하는 방법을 접하게 되었습니다. 현재는 사용자가 하나의 로또만 구매하는 형태이지만, 연금 복권이나 주택 복권 등 다양한 복권 구매 방식이 업데이트 될 경우, 객체지향의 다형성을 이용할 수 있는 구조를 구현하고 싶었습니다. 프리코스가 끝난후 이를 위해 Lotto를 추상화할 수 있는 인터페이스를 구현하고, Config.lotto(interface Lotto lotto)의 형태로 구현해보려고 합니다. 이 과정으로 '제어의 역전'을 완성하고 싶습니다. 다시말해 "User 클래스가 능동적으로 사용할 객체를 선택하지 못하고, 대신 Config 클래스에서 수동적으로 사용할 객체를 제공받는 형태"을 구현하여 유저가 로또를 선택하는 책임을 없애고 외부에서 로또를 선택하는 방향을 구상하였습니다.
  
"검증 클래스 분리"
  검증 기능을 별도의 클래스로 관리하는 것이 적절한지에 대한 고민을 해보았습니다. 클래스 분리의 목적은 1. 클래스의 길이를 줄이는 것, 2. 로또, 로또 판매자, 로또 구매자 등 비슷한 특성을 가진 클래스가 발생할 경우, 검증 메서드를 중복 생성하지 않도록 하는 것입니다. 만약 로또 판매 외에도 사용자 간의 거래가 가능하게 된다면, 또는 로또 종류가 다양해진다면, 검증 클래스를 별도로 구현하는 것이 편리할 것이라는 생각이 들었습니다. 그러나 동시에, 클래스를 과도하게 사용하는 것은 아닌지, 혹은 모든 검증 메서드를 하나의 검증 클래스에 넣는 것이 옳은지에 대한 의문을 가지고 있습니다.
  
"예외 처리"
  입력에 대한 예외 처리를 NumberFormatException을 사용하는 것이 적절한지에 대해 고민해 보았습니다. 이전까지는 예외 발생 시 출력문을 따로 출력하지 않았지만, 이번에는 예외 발생 내용을 출력하여 확인해 보았습니다. 그 결과, 공백을 입력했을 때 문자열 예외가 발생하는 등 예외 처리가 제대로 이루어지지 않는 점을 확인할 수 있었습니다. 
  이를 통해 1, 2주차의 과제에서도 예외 처리가 충분히 이루어지지 않았음을 인지하게 되었습니다. 이에 따라 "특수 문자, 문자 입력 검증"을 포함하여 "숫자 입력 검사"로 간소화하는 등, 오류 출력문이 오류 검증이 이루어지도록 변경해 보았습니다. 세상의 일을 프로그램으로 정의 하는 과정에서 많은 예외 사항이 있다는 것을 인지를 하고 있습니다. 일상의 일중에 예외에 대한 검증을 하는 연습을 하고있습니다. 
  
"일급 콜렉션"
  코드 리뷰를 진행하면서 일급 콜렉션을 사용하는 경우를 많이 보았습니다. 일급 콜렉션은 객체 지향 프로그래밍의 원칙을 준수하면서, 콜렉션 객체를 캡슐화하고 관련 메서드와 속성을 제공하는 방식을 말합니다. 이는 콜렉션에 대한 동작을 캡슐화하고, 내부 데이터를 안전하게 관리할 수 있으며, 특정 도메인 관련 로직, 유지보수, 확장이 용이하고 재할당이 불가능한 등의 특징을 가집니다. 저는 이번 과제에 LottoEnvelop, LottoTargetNumResults, WinLottoNumbers라는 세 개의 일급 컬렉션을 만들어 사용하고 학습해보았습니다. 일급 컬렉션은 컬렉션에 이름을 부여함으로써, 해당 컬렉션이 어떤 역할을 하는지, 왜 만들어졌는지를 쉽게 이해할 수 있게 해줍니다. LottoEnvelop 타입의 매개 변수를 선언하여 캡슐화된 컬렉션을 할당하는 것이 다른 타입을 할당하는 실수을 줄일수 있으며 또한, LottoEnvelop에 관련된 메서드를 구현해 사용함으로써 더욱 편리함을 느꼈습니다.
  
"클래스 분리"
  이번에는 클래스의 분리에 많은 신경을 썼습니다. 유저(User), 통계(Statistic), 수익률(RateResult), 판단(Judgment) 등으로 유저의 행동을 클래스로 나누어 보았습니다. 클래스 분리의 기준은 유저의 행위(메서드) 중에서 추상적이고 공통적인 부분을 독립시키는 것이었습니다. '유저가 통계를 계산하여 보여준다'는 것이 가장 기본적인 흐름입니다. 하지만 이를 '유저가 (당첨된 것들만, 당첨되지 않은 것만) 통계를 계산하여 보여준다'로 확장할 경우, 클래스의 분리가 확장성에 유리하다는 생각이 들어 분리를 진행하였습니다. 통계라는 클래스를 독립시킴으로써 다양한 통계 관련 메서드를 사용할 수 있게 되었고, 유저가 통계를 계산해야 한다는 책임을 분리할 수 있었습니다. 이러한 결과를 보니, 클래스를 분리한 것이 나름의 성공이라고 생각합니다.
  
"메서드 이름의 고찰"
   메서드의 이름에 대해서도 많은 고민을 했습니다. 로또 판매자의 메서드는 '판다'(sell), 로또 진행자는 '고른다'(pick), 유저는 '보여준다'(show), '가져간다'(take) 등으로, 각 객체의 행위를 메서드 이름으로 표현해 보려고 노력하였습니다. 이를 통해 메서드의 특징을 이름 그대로 표현하려 했습니다.

"enum 관리"
   enum의 적용 부분은 많이 어려운 것 같습니다. enum의 정의는 '서로 연관된 상수들의 집합'이라는 점을 기억하면서, 로또 등수에 따른 금액을 enum으로 분리하여 관리하였습니다. 처음에는 enum을 이용해서 등수에 따른 당첨 횟수를 세려고 했지만, 많은 오류가 발생했습니다. 원인을 찾아보니, enum은 생성과 동시에 모든 클래스와 공유되는 싱글톤이라는 것을 알게 되었습니다. 이는 학교에서 배웠던 싱글톤과 공유 자원의 개념이 실제로 나에게 적용되는 것을 보고, 바로 List을 이용해 count따로 관리 하였습니다. 
   이후에는 LottoRank.MONEY_FIFTH_PLACE(money, index)를 생성하여 관리하게 되었습니다. 그런데 여기서도 고민이 들었습니다. 과연 enum의 매개 변수에서 index를 관리하는 것이 옳은 것인가에 대한 고민이었습니다. 처음에는 enum.ordinal()을 이용해서 index를 관리하려고 했지만, enum의 순서에 따라 index가 변경되는 점이 마음에 걸려, 매개 변수에 index를 명시하여 안전하게 관리하는 방향으로 선택하였습니다.
   인터넷에는 다양한 enum의 사용법이 나와있어서, 프리 코스가 끝나고 나서 다른 방식으로 enum을 관리해보려고 생각하고 있습니다. 예를 들어, 일반 로또와 연금 로또는 각각 등수에 따른 금액이 다르고, 다양한 종류의 로또에 따라서도 금액이 다르기 때문에, LottoGroup.enum을 이용하여 각각의 Lotto.enum을 관리해 보는 것을 구상 중입니다. 이렇게 하면 좀 더 흥미로운 enum의 사용법을 연습해볼 수 있을 것 같습니다.
   
  
"이번 과제의 실수"
   이번 과제에서는 작은 단위의 클래스 (당첨 번호들의 모임, 보너스 번호 등)부터 구현하다보니 코드 수정이 많았습니다. 처음 클래스를 설계할 때 모든 클래스의 메서드를 명시하고, 나중에 구현하면서 간과한 부분을 비교하고 싶었습니다. 그런데 이번에는 작은 단위의 클래스부터 먼저 구현하여 도구로 사용하는 방법을 채택해 보았습니다. 그러나 이렇게 하니 제가 만든 클래스의 메서드를 사용하기 위해 코드 수정이 많이 필요했습니다. 2주차 피드백에서 말씀하신대로 "기능 목록을 클래스 설계와 구현, 함수(메서드) 설계와 구현과 같이 너무 상세하게 작성하지 않는다."는 조언을 받고 이해했습니다. 다음번엔 요구사항과 예외 처리 부분을 세밀하게 작성하여 좀 더 유연하게 대응하도록 해야겠습니다.
```



# 4주차 소감문

```
<abstract 클래스 적용>

이번 과제에서는 클래스의 분리를 최대한 고려하였고, 처음으로 abstract 클래스를 도입해 보았습니다.

'디데이', '주말', '평일', '특별 할인' 등 할인이라는 공통적인 부분을 기본 클래스로 설정하고, 오버라이딩을 메서드를 구현하는 방식을 시도해 보았습니다.

인터페이스를 선언하여 구현하고 싶었지만, 인터페이스 내에서 static을 구현해야 하는 부분이 마음에 걸려, 책에서만 보아 왔던 추상 클래스를 사용하여 구현하게 되었습니다.

Discount라는 기본 클래스를 상속받아 'dDayDiscount', 'weekDayDiscount', 'weekendDayDiscount', 'specialDayDiscount'를 선언하였고, 주문 날짜에 해당하는 혜택의 금액을 'Discount#giveAmount()'를 이용해 값을 얻는 과정에서 큰 희열을 느꼈습니다.

아직도 추상 클래스를 사용한 점에 대해 의심하고 있습니다. 더 나은 방법에 대한 확신이 없어, 코드 리뷰를 통해 다른 사람들과 이야기를 나누고 싶습니다.

그러나, 결과적으로는 성공적이었다고 생각합니다🤔

<enum 클래스 적용>

3주차 과제에서는 enum을 적용해 보았고, 더 많은 적용 사례를 공부한 뒤, 이번에는 메뉴 관리와 할인 날짜 관리에 도전해 보았습니다. Menu.enum 안에 메뉴의 이름과 가격을 선언하였고, MenuGroup.enum을 이용하여 찾고자 하는 이름이 메뉴에 있는지, 그리고 그 가격이 얼마인지를 알 수 있는 'MenuGroup#isMenu'와 'MenuGroup#getMenuPrice'을 사용하는 과정에서 상수을 어떻게 관리해야 하는지에 대한 이해를 더욱 깊게 하게 되었습니다.

enum을 단순히 상수를 관리하는 클래스라고 생각했었는데, 이번에 enum 안에 상수들을 이용해 관리해주는 메서드를 선언하고 사용하면서, enum과 interface, abstract등 모든건 만들어진 이유가 있으며, 클래스를 만들 때 생각을 많이 해야 한다는 것을 깨달았습니다

<ui을 View클래스에서 관리하고 domain은 비지니스 로직에 집중하라>

저는 클래스를 클래스 답게 관리하는 방법에 대해 고민하게 되었습니다. 클래스를 어떻게 클래스 답게 사용할 것인가를 고민하는 시간은 매우 가치 있는 시간이었습니다.

지금까지 클래스에 UI 관련 메서드를 만들었습니다. 당시에는 출력을 View에서 하니, UI와 비즈니스 로직이 분리되었다고 생각했었습니다. 하지만, 이는 완전한 분리가 아니었다는 것을 깨달았습니다.

'비즈니스 로직과 UI 로직을 한 클래스가 담당하지 않도록 한다. 이는 단일 책임 원칙에도 위배된다.'라는 말을 보며 UI 클래스를 제외한 클래스들은 값의 이동만 책임지며, 사용자에게 보여지는 UI 클래스에서는 UI 작업만 담당한다는 것을 이해하게 되었습니다. , 책임에 대한 이해도가 높아졌습니다.

<클래스 분리>

'private 함수를 테스트 하고 싶다면 클래스(객체) 분리를 고려한다'라는 말을 보고, 이번 과제를 진행하면서 이를 고려해보기로 결정했습니다. 클래스를 분리하는 것은 정말 어려운 작업입니다. 과도하게 분리하면 클래스의 남용이 되어 이해하는 데 어려움을 겪을 수 있습니다. 하지만 선생님들의 피드백은 이 과정에서 큰 도움이 되었습니다.

Champagne.class, Parse.class, OrderCalculator.class, PaymentCalculator.class 등의 클래스들은 '가독성 이상의 역할을 하는 경우, 테스트하기 쉽게 구현하기 위해서는 해당 역할을 수행하는 다른 객체를 만들 타이밍이 아닐지 고민해 볼 수 있다.'라는 글에서 힌트를 얻어 클래스 분리를 시도해보았습니다.

가독성 이상의 역할을 하는 private 메서드는 클래스의 책임을 가지고 있으며, 이런 분할 과정을 통해 클래스의 책임을 줄이는 과정을 공부하고 생각해보는 것이 유익했습니다. 이런 훈련은 점차 많은 클래스 간의 관계성을 구상하는 데 도움이 된다고 확신하고 있습니다.

<테스트 코드>

지금까지 저는 테스트 메서드의 이름을 테스트하고 싶은 메서드의 이름으로 사용하였습니다. 그러나 그렇게 하다 보니, 메서드를 변경하였을 때 테스트 메서드 역시 변경해야 하는 작업이 생기게 되었습니다. 그래서 메서드가 하는 역할이나 기능에 대한 이름을 부여하여 테스트를 진행하는 것이 더 좋겠다는 생각을 하였고, 테스트 메서드의 이름을 변경하게 되었습니다.

테스트 코드는 지금까지 제가 만든 메서드가 제대로 반환을 하는지에 대한 테스트를 진행하였지만, 생각을 확장해 보니 내가 지금 작업하는 기능을 먼저 확인하는 것이 테스트 코드라는 저만의 생각을 가지게 되었습니다.

'단위 테스트하기 어려운 코드를 단위 테스트하기'라는 피드백을 계속 상기하며 코드를 작성하였습니다. 단위 테스트를 하기 어려운 코드는 많은 책임을 가지고 있는 코드를 의미하는 것 같습니다. 이는 책임을 분할하는 과정을 말하는 것 같습니다. 앞으로도 선생님들의 피드백을 곱씹어 보며, 저만의 생각을 가지고 싶습니다.

<문제점>

전체적인 클래스를 살펴볼 때, Order.class가 다른 클래스에 너무 많이 종속되어 있어 클래스 분리가 어렵다는 것을 느꼈습니다. 지금도 분리가 가능한지, 분리가 맞는지에 대한 확신이 서지 않습니다. 다음에 설계와 구상을 할 때에는 이 점을 참고하여 작업을 해야겠다는 생각을 하였습니다.

혜택을 관리하는 Benefit.class를 생성하기 위해서는 Order 클래스를 매개변수로 사용하여 생성해야 합니다. 저는 Order와 Benefit을 분리하여 사용하고 싶었지만, 그것이 불가능하다는 것을 알게 되었습니다.

객체의 독립성을 유지하면서 설계하는 것이 어렵다는 것을 다시 한번 상기하였고, 많은 전공 책과 다른 사람들의 의견을 참조하면서 계속 생각을 정리하는 시간을 가져야겠다는 결심을 하였습니다.
```





---

# 테스트 공부 코드

```java
package study;

import static org.assertj.core.api.Assertions.*;
import static org.junit.jupiter.api.Assertions.*;

import org.assertj.core.api.StringAssert;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.*;

import java.io.*;
import java.util.*;
import java.util.concurrent.TimeUnit;

// https://assertj.github.io/doc/#overview-what-is-assertj
public class StringTest {

    @Test
    void split_메서드로_주어진_값을_구분() {
        String input = "1,2";
        String[] result = input.split(",");

        assertThat(result).contains("2", "1");

        // 특정 결과가 주어진 순서대로 "1"과 "2"를 포함하는지 확인
        assertThat(result).containsExactly("1", "2");
    }

    // TODO: 10/31/23 활용해보기.
    @Test
    void split_메서드_사용시_구분자가_포함되지_않은_경우_값을_그대로_반환() {
        String input = "1";
        String[] result = input.split(",");

        assertThat(result).contains("1");
    }

    @Test
    void substring_메서드로_특정_구간_값을_반환() {
        String input = "(1,2)";
        String result = input.substring(1, 4);

        assertThat(result).isEqualTo("1,2");
    }

    @Test
    void charAt_메서드로_특정_위치의_문자_찾기() {
        String input = "abc";
        char charAtElement = input.charAt(0);
        assertThat(charAtElement).isEqualTo('a');
    }

    @Test
    void charAt_메서드_사용시_문자열의_길이보다_큰_숫자_위치의_문자를_찾을_때_예외_발생() {
        String input = "abc";

        assertThatThrownBy(() -> input.charAt(5))
                .isInstanceOf(StringIndexOutOfBoundsException.class)
                .hasMessageContaining("String index out of range: 5");
    }

    @DisplayName("CsvSource을 이용한 테스트 활용")
    @ParameterizedTest
    @CsvSource({"abc,1,true", "def,2,false"})
    public void CsvSource_활용하여_여러개_테스트_확인하기(String str, int num, boolean isTrue) throws Exception {
        assertThat(str).contains(str);
        assertThat(num).isEqualTo(num);
        assertThat(isTrue).isEqualTo(isTrue);
    }

    @ParameterizedTest(name = "매개변수") // 무조건 name으로
    @ValueSource(strings = {"abc", "def", "ghi"})
    @DisplayName("ValueSource을 이용한 테스트 활용_1")
    void ValueSource_을_활용하여_여러개_테스트_확인하기_문자(String str) {
        assertThat(str).contains(str);
    }

    @ParameterizedTest(name = "매개변수") // 무조건 name으로
    @ValueSource(ints = {1, 2, 3})
    @DisplayName("ValueSource을 이용한 테스트 활용_2")
    void ValueSource_을_활용하여_여러개_테스트_확인하기_숫자(int num) {
        assertThat(num).isEqualTo(num);
    }

    @ParameterizedTest(name = "매개변수") // 무조건 name으로
    @ValueSource(booleans = {true, false})
    @DisplayName("ValueSource을 이용한 테스트 활용_3")
    void ValueSource_을_활용하여_여러개_테스트_확인하기_불(boolean isTrue) {
        assertThat(isTrue).isEqualTo(isTrue);
    }

    @ParameterizedTest
    @NullSource
    @EmptySource
    @DisplayName("NullSource, EmptySource의 에너테이션을 이용한 NULL, EMPTY 테스트")
    void NULL_EMPTY_을_활용한_테스트(String text) {
        assertTrue(text == null || text.trim().isEmpty());
    }

    @ParameterizedTest
    @NullAndEmptySource
    @DisplayName("NullAndEmptySource의 에너테이션을 이용한 NULL, EMPTY 테스트")
    @ValueSource(strings = {" ", "   ", "\t", "\n"})
    void NullAndEmptySource_을_활용한_테스트(String text) {
        assertTrue(text == null || text.trim().isEmpty());
    }


    @DisplayName("assertThrows_을_이용한_예외를_테스트")
    @Test
    void assertThrows_을_이용한_예외를_테스트() {
        String input = "abc";

        // when then
        assertThrows(StringIndexOutOfBoundsException.class, () -> input.charAt(5));
    }

    @DisplayName("assertThatThrownBy_을_이용한_예외를_테스트")

    @Test
    public void assertThatThrownBy_을_이용한_예외를_테스트() {
        assertThatThrownBy(() -> {
            throw new Exception("boom!");
        }).isInstanceOf(Exception.class)
                .hasMessageContaining("boom");
    }

    @DisplayName("assertThatExceptionOfType_을_이용한_예외를_테스트")
    @Test
    public void assertThatExceptionOfType_을_이용한_예외를_테스트() {
        assertThatExceptionOfType(IOException.class)
                .isThrownBy(() -> {
                    throw new IOException("boom!");
                })
                .withMessage("%s!", "boom") // 예외 메시지가 "boom!"과 일치하는지 확인하고
                .withMessageContaining("boom") // 메시지에 "boom"이 포함되어 있는지 확인하고
                .withNoCause(); // 예외가 특정 원인을 갖지 않는지 확인한다.

//        코드에서 withMessage("%s!", "boom")는
//        문자열 "boom"을 %s 자리 표시자에 대체하고,
//        그 뒤에 느낌표를 추가하여 "boom!"이라는 문자열을 생성합니다.
    }

    @DisplayName("out_출력_확인_테스트")
    @Test
    void out_출력_확인_테스트() {
        // given
        // 출력을 위한 테스트
        ByteArrayOutputStream outContent = new ByteArrayOutputStream();
        System.setOut(new PrintStream(outContent));

        // when
        System.out.println();

        // than
        assertThat(outContent.toString()).isEqualTo("\n");
    }

    @DisplayName("List의_모든_원소에_대한_확인_하는_테스트")
    @Test
    public void List의_모든_원소에_대한_확인_하는_테스트() throws Exception {
        // given
        List<Integer> resultList = List.of(1, 1, 1, 1, 1);

        // then
        assertThat(resultList).allMatch((value) -> {
            return value.equals(1);
        });
    }

    @DisplayName("두개의_List가_같은지_확인하는_테스트")
    @Test
    void 두개의_List가_다른지_확인하는_테스트() throws Exception {
        //given
        List<Integer> resultList_1 = List.of(1, 2, 3);
        List<Integer> resultList_2 = List.of(3, 4, 5);

        // then
        // 방법 1 assertNotEquals
        assertNotEquals(resultList_1, resultList_2);
        // 방법 2 assertThat().isFalse
        assertThat(resultList_1.equals(resultList_2)).isFalse();
    }

    @DisplayName("두개의_List가_같은지_확인하는_테스트")
    @Test
    void 두개의_List가_같은지_확인하는_테스트() throws Exception {
        //given
        List<Integer> resultList_1 = List.of(1, 2, 3);
        List<Integer> resultList_2 = List.of(1, 2, 3);

        // then
        // 방법 1 assertEquals
        assertEquals(resultList_1, resultList_2);
        // 방법 2 assertThat().isTrue
        assertThat(resultList_1.equals(resultList_2)).isTrue();
    }

    @DisplayName("문자열_검증")
    @Test
    void 문자열_검증() {
        String expression = "This is a string";
        assertThat(expression).startsWith("This").endsWith("string").contains("a");
    }

    @DisplayName("EnumSource_을_이용한_ENUM_포함에_관한_테스트")
    @ParameterizedTest
//          value = Enum의 클래스 정의  names =  Enum의 값을 정의
    @EnumSource(value = TimeUnit.class, names = {"DAYS", "HOURS"})
    void EnumSource_을_이용한_ENUM_포함에_관한_테스트(TimeUnit inputTimeUnit) {
        assertTrue(
                EnumSet.of(TimeUnit.DAYS, TimeUnit.HOURS).contains(inputTimeUnit)
        );
    }

    @DisplayName("contains_을_활용한_하나라도_포함이_되어있으면_테스트_통과")
    @Test
    public void contains_을_활용한_하나라도_포함이_되어있으면_테스트_통과() throws Exception {
        String input = "1,,23";
        String[] result = input.split(",");

        assertThat(result).contains("1");
        assertThat(result).contains("1", "23");
    }

    @DisplayName("containsAnyOf_을_활용한_이중에_하나가_포함되어있으면_테스트_통과_1")
    @Test
    void containsAnyOf_을_활용한_이중에_하나가_포함되어있으면_테스트_통과_1() {
        assertThat("The Lord of the Rings")
                // 널이 아니고
                .isNotNull()
                // The로 시작하고
                .startsWith("The")
                // Lord가 포함하고
                .contains("Lord")
                .contains("of")
                // 이중에 하나가 포함되었다.
                .containsAnyOf("the", "rings")
                // 끝이 Rings이다.
                .endsWith("Rings");
    }

    @DisplayName("containsAnyOf_을_활용한_이중에_하나가_포함되어있으면_테스트_통과_1")
    @Test
    void containsAnyOf_을_활용한_이중에_하나가_포함되어있으면_테스트_통과_2() {
        assertThat("123")
                // 널이 아니고
                .isNotNull()
                // The로 시작하고
                .startsWith("1")
                // Lord가 포함하고
                .contains("3")
                .contains("2")
                // 이중에 하나가 포함되었다.
                .containsAnyOf("1", "aslkdjasd", "아무단어")
                // 끝이 Rings이다.
                .endsWith("3");
    }

    @DisplayName("containsExactly_을_활용한_정확한_순서로_리스트에_포함되어_있는가_테스트")
    @Test
    void containsExactly_을_활용한_정확한_순서로_리스트에_포함되어_있는가_테스트() {
        String input = "1,,23";
        String[] result = input.split(",");

        // 정확하게 들어있는가
        assertThat(result).containsExactly("1", "", "23");
    }

    @DisplayName("containsOnly_을_활용하여_원소값과_갯수가_정확히_일치_테스트")
    @Test
    public void containsOnly_을_활용하여_원소값과_갯수가_정확히_일치_테스트() throws Exception {
        List<String> list = List.of("apple", "banana", "orange", "americano");

        //  이름을 가져와서 a 가 포함되어 있는 객체들만 필터링을 하고 그 객체를 검증한다.
        assertThat(list)
                .filteredOn(value -> value.contains("apple")) // 'apple'를 포함하는 객체들을 필터링하고
                .containsOnly("apple"); // 'banana'과 'orange'만을 포함하는지 검증한다.
    }

    @DisplayName("filterOn_을_활용하여_원소값과_갯수가_정확히_일치_테스트")
    @Test
    public void filterOn_필터링하고_객체_검증_일치_테스트() throws Exception {
        List<String> list = List.of("apple", "banana", "orange", "americano");

        //  이름을 가져와서 a 가 포함되어 있는 객체들만 필터링을 하고 그 객체를 검증한다.
        assertThat(list)
                .filteredOn(value -> value.contains("apple")) // 'apple'를 포함하는 객체들을 필터링하고
                .containsOnly("apple"); // 'banana'과 'orange'만을 포함하는지 검증한다.
    }

    @DisplayName("기본적인_assertions_사용법")
    @Test
    public void 기본적인_assertions_사용법() throws Exception {
        Human frodo = new Human("Frodo");
        Human sauron = new Human("Sauron");

        // basic assertions
        assertThat(frodo.getName()).isEqualTo("Frodo");
        assertThat(frodo).isNotEqualTo(sauron);

        // chaining string specific assertions
        assertThat(frodo.getName()).startsWith("Fro")
                .endsWith("do")
                .isEqualToIgnoringCase("frodo");
    }

    @DisplayName("collection_에_Assertions_적용하기")
    @Test
    public void collection_에_Assertions_적용하기() throws Exception {
        // given
        Human frodo = new Human("Frodo");
        Human sam = new Human("Sam");
        Human seung = new Human("Seung");
        Human chan = new Human("Chan");
        Human sauron = new Human("Sauron");

        List<Human> fellowshipOfTheRing = List.of(frodo, sam, seung, chan);

        // than
        assertThat(fellowshipOfTheRing).hasSize(4)
                .contains(frodo, sam)
                .doesNotContain(sauron);
    }

    @DisplayName("as_을_활용한_메세지보내기")
    @Test
    public void as_을_활용한_메세지보내기() throws Exception {
        // given
        Human frodo = new Human("Frodo");

        // then
        // as()는 테스트를 설명하는 데 사용되며 오류 메시지 앞에 표시됩니다.
        // 오류일때 as() 발동
        // ex) org.opentest4j.AssertionFailedError: [check Frodo's age]
        assertThat(frodo.getAge()).as("check %s's age", frodo.getName()).isEqualTo(33);
        assertThat(frodo.getAge()).as("check %s's age", frodo.getAge()).isEqualTo(33);
        assertThat(frodo.getAge()).as("check %s's age", frodo.isTrue()).isEqualTo(33);
    }

    @DisplayName("Satisfy_을_활용한_assertions_List_확인하기")
    @Test
    public void Satisfy_을_활용한_assertions_List_확인하기() throws Exception {
        // given
        Human frodo = new Human("Frodo");
        Human sam = new Human("Sam");
        Human pippin = new Human("Pippin");

        List<Human> humansList = List.of(frodo, sam, pippin);

        // than
        // 모든 요소는 주어진 주장을 만족해야 합니다.
        assertThat(humansList).allSatisfy(human -> {
            assertThat(human.getName()).isNotEqualTo("Sauron");
        });

        // 최소한 하나의 요소가 주어진 주장을 만족해야 합니다.
        assertThat(humansList).anySatisfy(human -> {
            assertThat(human.getName()).isEqualTo("Sam");
        });

        // 어떤 요소도 주어진 주장을 만족해서는 안 됩니다.
        assertThat(humansList).noneSatisfy(human ->
                assertThat(human.getName()).isEqualTo("NOTTING")
        );
    }

    @DisplayName("allMatch_anyMatch_noneMatch_을_활용한_테스트")
    @Test
    public void allMatch_anyMatch_noneMatch_을_활용한_테스트() throws Exception {
        // given
        Human frodo = new Human("Frodo");
        Human sam = new Human("Sam");
        Human pippin = new Human("Pippin");

        List<Human> humansList = List.of(frodo, sam, pippin);

        // than
        assertThat(humansList).
                // 모든 요소는 주어진 주장을 만족해야 합니다.
                        allMatch(human -> human.getAge() == 33, "age")

                // 모든 요소는 주어진 주장을 만족해야 합니다.
                .allMatch(human -> human.getAge() == 33)

                // 최소한 하나의 요소가 주어진 주장을 만족해야 합니다.
                .anyMatch(character -> character.getName().contains("pp"))

                // 어떤 요소도 주어진 주장을 만족해서는 안 됩니다.
                .noneMatch(character -> character.getName() == "NOTTING");
    }

    @DisplayName("element_index_을_활용한_테스트")
    @Test
    public void element_index_을_활용한_테스트() throws Exception {
        // given
        Human frodo = new Human("Frodo");
        Human sam = new Human("Sam");
        Human pippin = new Human("Pippin");

        List<Human> humansList = List.of(frodo, sam, pippin);

        // then
        // index을 활용한 List 탐색
        assertThat(humansList).first().isEqualTo(frodo);
        assertThat(humansList).element(1).isEqualTo(sam);
        assertThat(humansList).last().isEqualTo(pippin);

        // 강력한 문자열 TYPE Assertions 테스트
        Iterable<String> humanName = List.of("frodo", "sam", "pippin");

        // STRING is 문자표식
        // as()은 가독성을 위한 표식
        assertThat(humanName).first(as(STRING))
                .startsWith("fro")
                .endsWith("do");

        assertThat(humanName).element(1, as(STRING))
                .startsWith("sa")
                .endsWith("am");

        assertThat(humanName).last(as(STRING))
                .startsWith("pip")
                .endsWith("pin");

        // 강력한 TYPE Assertions 테스트
        assertThat(humanName, StringAssert.class).first()
                .startsWith("fro")
                .endsWith("do");
    }

    @DisplayName("단일_요소_list_의_테스트_방법")
    @Test
    public void 단일_요소_list_의_테스트_방법() throws Exception {
        // given
        List<String> oneList = List.of("Maggie");

        // then
        // 단일 요소의 리스트인지 확인한다.
        assertThat(oneList).singleElement()
                .isEqualTo("Maggie");

        // 단일 요소의 리스트 확인 => 문자열 테스트.
        assertThat(oneList).singleElement(as(STRING))
                .endsWith("gie");

        // 단일 요소확인 => 문자열 TYPE 확인
        assertThat(oneList, StringAssert.class).singleElement()
                .startsWith("Mag");
    }

    @DisplayName("속성_property_필드_field_in_notIn_not_값을_확인하는_메서드_테스트")
    @Test
    public void 속성_property_필드_field_in_notIn_not_값을_확인하는_메서드_테스트() throws Exception {
        // given
        Human frodo = new Human("Frodo");
        Human frodo2 = new Human("Frodo2");
        Human sam = new Human("Sam");
        Human sam2 = new Human("Sam2");
        Human pippin = new Human("Pippin");
        Human pippin2 = new Human("Pippin2", 12);

        List<Human> humansList = List.of(frodo, sam, pippin, frodo2, sam2, pippin2);

        // then
        // filter을 사용을 한다. 속성의 이름(property), 멤버 변수(field)의 이름정의
        assertThat(humansList).filteredOn("age", 33)
                .filteredOn("name", "Frodo")
                .containsOnly(frodo);

//        // filter에서 여러 속성 확인하는 방법 notIn()
        assertThat(humansList)
                .filteredOn("name", notIn("Sam", "Sam2", "Pippin", "Pippin2"))
                .containsOnly(frodo, frodo2);

        // filter에서 여러 속성 확인하는 방법 in()
        assertThat(humansList).filteredOn("name", in("Frodo", "Frodo2"))
                .containsOnly(frodo, frodo2);

        // filter에서 하나만 아니다.
        assertThat(humansList).filteredOn("name", not("Sam"))
                .containsOnly(frodo, pippin, frodo2, sam2, pippin2);

//        // 여러 필드 사용하기.
        assertThat(humansList).filteredOn("name", "Pippin")
                .filteredOn("age", not(12))
                .containsOnly(pippin);
    }

    @DisplayName("filter_을_활용한_미만_값을_필터하는_방법")
    @Test
    public void filter_을_활용한_미만_값을_필터하는_방법() throws Exception {
        // given
        Human frodo = new Human("Frodo", 12);
        Human sam = new Human("Sam", 20);
        Human pippin = new Human("Pippin", 30);

        List<Human> humansList = List.of(frodo, sam, pippin);

        // then
        // 25 미만 isLessThan
        assertThat(humansList).filteredOnAssertions(human ->
                        assertThat(human.getAge()).isLessThan(25))
                .containsOnly(frodo, sam);

        // 20 이하 isLessThanOrEqualTo
        assertThat(humansList).filteredOnAssertions(human ->
                        assertThat(human.getAge()).isLessThanOrEqualTo(20))
                .containsOnly(frodo, sam);

        // 25 초과 isGreaterThan
        assertThat(humansList).filteredOnAssertions(human ->
                        assertThat(human.getAge()).isGreaterThan(25))
                .containsOnly(pippin);

    }

    @DisplayName("extracting_을_활용한_속성_추출_방법")
    @Test
    public void extracting_을_활용한_속성_추출_방법() throws Exception {
        // given
        Human kawhi = new Human("kawhi", 25);
        Human seung = new Human("seung", 25);
        Human chan = new Human("chan", 25);
        List<Human> humanList = new ArrayList<>();
        humanList.add(kawhi);
        humanList.add(seung);
        humanList.add(chan);

        // than
        // 추출한 것의 따로 리스트를 만든다.
        assertThat(humanList).extracting("name")
                .containsOnly(kawhi.getName(), seung.getName(), chan.getName()); // DOES NOT COMPILE

        // Use Object assertions like isEqualTo
        assertThat(humanList).extracting(Human::getName)
                .containsOnly(kawhi.getName(), seung.getName(), chan.getName()); // DOES NOT COMPILE

    }

}

class Human {
    private String name;
    private int age;
    private boolean isTrue;

    public Human(String name) {
        this.name = name;
        age = 33;
        isTrue = true;
    }

    public Human(String name, int aage) {
        this.name = name;
        age = aage;
        isTrue = true;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public boolean isTrue() {
        return isTrue;
    }

    @Override
    public String toString() {
        return name + " " + age;
    }
}
```





# 4주차

```java
package christmas.constant.discount;

public enum Discount {
    // 디 디데이 할인
    D_DAY_ONE(1, 1000),
    D_DAY_TWO(2, 1100),
    D_DAY_THREE(3, 1200),
    D_DAY_FOUR(4, 1300),
    D_DAY_FIVE(5, 1400),
    D_DAY_SIX(6, 1500),
    D_DAY_SEVEN(7, 1600),
    D_DAY_EIGHT(8, 1700),
    D_DAY_NINE(9, 1800),
    D_DAY_TEN(10, 1900),
    D_DAY_ELEVEN(11, 2000),
    D_DAY_TWELVE(12, 2100),
    D_DAY_THIRTEEN(13, 2200),
    D_DAY_FOURTEEN(14, 2300),
    D_DAY_FIFTEEN(15, 2400),
    D_DAY_SIXTEEN(16, 2500),
    D_DAY_SEVENTEEN(17, 2600),
    D_DAY_EIGHTEEN(18, 2700),
    D_DAY_NINETEEN(19, 2800),
    D_DAY_TWENTY(20, 2900),
    D_DAY_TWENTY_ONE(21, 3000),
    D_DAY_TWENTY_TWO(22, 3100),
    D_DAY_TWENTY_THREE(23, 3200),
    D_DAY_TWENTY_FOUR(24, 3300),
    D_DAY_TWENTY_FIVE(25, 3400),

    // 평일 할인
    WEEK_DAY_THREE(3, 2023),
    WEEK_DAY_FOUR(4, 2023),
    WEEK_DAY_FIVE(5, 2023),
    WEEK_DAY_SIX(6, 2023),
    WEEK_DAY_SEVEN(7, 2023),
    WEEK_DAY_TEN(10, 2023),
    WEEK_DAY_ELEVEN(11, 2023),
    WEEK_DAY_TWELVE(12, 2023),
    WEEK_DAY_THIRTEEN(13, 2023),
    WEEK_DAY_FOURTEEN(14, 2023),
    WEEK_DAY_SEVENTEEN(17, 2023),
    WEEK_DAY_EIGHTEEN(18, 2023),
    WEEK_DAY_NINETEEN(19, 2023),
    WEEK_DAY_TWENTY(20, 2023),
    WEEK_DAY_TWENTY_ONE(21, 2023),
    WEEK_DAY_TWENTY_FOUR(24, 2023),
    WEEK_DAY_TWENTY_FIVE(25, 2023),
    WEEK_DAY_TWENTY_SIX(26, 2023),
    WEEK_DAY_TWENTY_SEVEN(27, 2023),
    WEEK_DAY_TWENTY_EIGHT(28, 2023),
    WEEK_DAY_THIRTY_ONE(31, 2023),

    // 주말 할인
    WEEKEND_DAY_ONE(1, 2023),
    WEEKEND_DAY_TWO(2, 2023),
    WEEKEND_DAY_EIGHT(8, 2023),
    WEEKEND_DAY_NINE(9, 2023),
    WEEKEND_DAY_FIFTEEN(15, 2023),
    WEEKEND_DAY_SIXTEEN(16, 2023),
    WEEKEND_DAY_TWENTY_TWO(22, 2023),
    WEEKEND_DAY_TWENTY_THREE(23, 2023),
    WEEKEND_DAY_TWENTY_NINE(29, 2023),
    WEEKEND_DAY_THIRTY(30, 2023),

    // 특별 할인
    SPECIAL_DAY_THREE(3, 2023),
    SPECIAL_DAY_TEN(10, 2023),
    SPECIAL_DAY_SEVENTEEN(17, 2023),
    SPECIAL_DAY_TWENTY_FOUR(24, 2023),
    SPECIAL_DAY_TWENTY_FIVE(25, 2023),
    SPECIAL_DAY_THIRTY_ONE(31, 2023);

    private final int day;
    private final int discountAmount;

    Discount(int day, int discountAmount) {
        this.day = day;
        this.discountAmount = discountAmount;
    }

    public int getDay() {
        return day;
    }

    public int getDiscountAmount() {
        return discountAmount;
    }
}

```

---

